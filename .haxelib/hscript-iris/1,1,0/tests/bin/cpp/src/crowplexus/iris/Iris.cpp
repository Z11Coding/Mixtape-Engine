// Generated by Haxe 4.3.5
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Reflect
#include <Reflect.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_Sys
#include <Sys.h>
#endif
#ifndef INCLUDED_crowplexus_hscript_Expr
#include <crowplexus/hscript/Expr.h>
#endif
#ifndef INCLUDED_crowplexus_hscript_Interp
#include <crowplexus/hscript/Interp.h>
#endif
#ifndef INCLUDED_crowplexus_hscript_Parser
#include <crowplexus/hscript/Parser.h>
#endif
#ifndef INCLUDED_crowplexus_iris_InitRules
#include <crowplexus/iris/InitRules.h>
#endif
#ifndef INCLUDED_crowplexus_iris_Iris
#include <crowplexus/iris/Iris.h>
#endif
#ifndef INCLUDED_haxe_Exception
#include <haxe/Exception.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Log
#include <haxe/Log.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_362e1cea85625f87_22_new,"crowplexus.iris.Iris","new",0x15b766d6,"crowplexus.iris.Iris.new","crowplexus/iris/Iris.hx",22,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_96_fixScriptName,"crowplexus.iris.Iris","fixScriptName",0xeb8a1621,"crowplexus.iris.Iris.fixScriptName","crowplexus/iris/Iris.hx",96,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_108_execute,"crowplexus.iris.Iris","execute",0xdb3c13ab,"crowplexus.iris.Iris.execute","crowplexus/iris/Iris.hx",108,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_126_parse,"crowplexus.iris.Iris","parse",0xa3a43029,"crowplexus.iris.Iris.parse","crowplexus/iris/Iris.hx",126,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_137_preset,"crowplexus.iris.Iris","preset",0x4d3e0aa9,"crowplexus.iris.Iris.preset","crowplexus/iris/Iris.hx",137,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_151_get,"crowplexus.iris.Iris","get",0x15b2170c,"crowplexus.iris.Iris.get","crowplexus/iris/Iris.hx",151,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_165_set,"crowplexus.iris.Iris","set",0x15bb3218,"crowplexus.iris.Iris.set","crowplexus/iris/Iris.hx",165,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_188_call,"crowplexus.iris.Iris","call",0xe37a2968,"crowplexus.iris.Iris.call","crowplexus/iris/Iris.hx",188,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_218_exists,"crowplexus.iris.Iris","exists",0x5e5d7526,"crowplexus.iris.Iris.exists","crowplexus/iris/Iris.hx",218,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_232_destroy,"crowplexus.iris.Iris","destroy",0x33b53670,"crowplexus.iris.Iris.destroy","crowplexus/iris/Iris.hx",232,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_260_irisPrint,"crowplexus.iris.Iris","irisPrint",0xe2a8b210,"crowplexus.iris.Iris.irisPrint","crowplexus/iris/Iris.hx",260,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_248_destroyAll,"crowplexus.iris.Iris","destroyAll",0x472a2091,"crowplexus.iris.Iris.destroyAll","crowplexus/iris/Iris.hx",248,0x27ccb4fa)
HX_LOCAL_STACK_FRAME(_hx_pos_362e1cea85625f87_26_boot,"crowplexus.iris.Iris","boot",0xe2db94fc,"crowplexus.iris.Iris.boot","crowplexus/iris/Iris.hx",26,0x27ccb4fa)
namespace crowplexus{
namespace iris{

void Iris_obj::__construct(::String scriptCode, ::crowplexus::iris::InitRules rules){
            	HX_GC_STACKFRAME(&_hx_pos_362e1cea85625f87_22_new)
HXLINE(  63)		this->interpErrStr = HX_("Careful, the interpreter hasn't been initialized",aa,53,52,05);
HXLINE(  43)		this->scriptCode = HX_("",00,00,00,00);
HXLINE(  36)		this->ruleSet = null();
HXLINE(  31)		this->running = false;
HXLINE(  75)		if (::hx::IsNull( rules )) {
HXLINE(  76)			rules =  ::crowplexus::iris::InitRules_obj::__alloc( HX_CTX ,HX_("Iris",33,70,97,30),true,true);
            		}
HXLINE(  78)		this->scriptCode = scriptCode;
HXLINE(  79)		this->ruleSet = rules;
HXLINE(  81)		this->parser =  ::crowplexus::hscript::Parser_obj::__alloc( HX_CTX );
HXLINE(  82)		this->interp =  ::crowplexus::hscript::Interp_obj::__alloc( HX_CTX );
HXLINE(  84)		this->parser->allowTypes = true;
HXLINE(  85)		this->parser->allowMetadata = true;
HXLINE(  86)		this->parser->allowJSON = true;
HXLINE(  87)		this->fixScriptName(rules->name);
HXLINE(  89)		if (this->ruleSet->preset) {
HXLINE(  90)			this->preset();
            		}
HXLINE(  92)		if (rules->autoRun) {
HXLINE(  93)			this->execute();
            		}
            	}

Dynamic Iris_obj::__CreateEmpty() { return new Iris_obj; }

void *Iris_obj::_hx_vtable = 0;

Dynamic Iris_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< Iris_obj > _hx_result = new Iris_obj();
	_hx_result->__construct(inArgs[0],inArgs[1]);
	return _hx_result;
}

bool Iris_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2e02612a;
}

void Iris_obj::fixScriptName(::String defaultName){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_96_fixScriptName)
HXLINE(  98)		int copyID = 1;
HXLINE(  99)		while(::crowplexus::iris::Iris_obj::instances->exists(this->ruleSet->name)){
HXLINE( 100)			this->ruleSet->name = ((defaultName + HX_("_",5f,00,00,00)) + copyID);
HXLINE( 101)			copyID = (copyID + 1);
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(Iris_obj,fixScriptName,(void))

 ::crowplexus::iris::Iris Iris_obj::execute(){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_108_execute)
HXLINE( 109)		bool _hx_tmp;
HXDLIN( 109)		if (!(this->running)) {
HXLINE( 109)			_hx_tmp = ::hx::IsNull( this->interp );
            		}
            		else {
HXLINE( 109)			_hx_tmp = true;
            		}
HXDLIN( 109)		if (_hx_tmp) {
HXLINE( 111)			::String _hx_tmp1;
HXDLIN( 111)			if (::hx::IsNull( this->interp )) {
HXLINE( 111)				_hx_tmp1 = (this->interpErrStr + HX_(", Aborting.",a8,e7,d8,50));
            			}
            			else {
HXLINE( 111)				_hx_tmp1 = ((HX_("Script ",95,23,35,fa) + this->ruleSet->name) + HX_(" is already running!",a0,17,79,9c));
            			}
HXDLIN( 111)			::haxe::Log_obj::trace((HX_("[Iris:execute()]: ",f9,11,ed,3b) + _hx_tmp1),::hx::SourceInfo(HX_("../crowplexus/iris/Iris.hx",eb,c2,00,2a),111,HX_("crowplexus.iris.Iris",e4,03,e2,62),HX_("execute",35,0a,0d,cc)));
HXLINE( 113)			return ::hx::ObjectPtr<OBJ_>(this);
            		}
HXLINE( 116)		::crowplexus::iris::Iris_obj::instances->set(this->ruleSet->name,::hx::ObjectPtr<OBJ_>(this));
HXLINE( 118)		if (::hx::IsNull( this->expr )) {
HXLINE( 119)			this->expr = this->parse();
            		}
HXLINE( 120)		this->interp->execute(this->expr);
HXLINE( 121)		this->running = ::crowplexus::iris::Iris_obj::instances->exists(this->ruleSet->name);
HXLINE( 123)		return ::hx::ObjectPtr<OBJ_>(this);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Iris_obj,execute,return )

 ::crowplexus::hscript::Expr Iris_obj::parse(){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_126_parse)
HXLINE( 127)		if (this->running) {
HXLINE( 128)			return this->expr;
            		}
HXLINE( 129)		if (::hx::IsNotNull( this->expr )) {
HXLINE( 130)			return this->expr;
            		}
HXLINE( 131)		return (this->expr = this->parser->parseString(this->scriptCode,null()));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Iris_obj,parse,return )

void Iris_obj::preset(){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_137_preset)
HXLINE( 138)		this->set(HX_("Std",83,60,3f,00),::hx::ClassOf< ::Std >(),null());
HXLINE( 139)		this->set(HX_("Math",e8,6d,2f,33),::hx::ClassOf< ::Math >(),null());
HXLINE( 140)		this->set(HX_("StringTools",6a,db,63,03),::hx::ClassOf< ::StringTools >(),null());
HXLINE( 143)		this->set(HX_("trace",85,8e,1f,16),this->irisPrint_dyn(),true);
            	}


HX_DEFINE_DYNAMIC_FUNC0(Iris_obj,preset,(void))

 ::Dynamic Iris_obj::get(::String field){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_151_get)
HXLINE( 153)		if (::hx::IsNull( this->interp )) {
HXLINE( 154)			::haxe::Log_obj::trace(((HX_("[Iris:get()]: ",f8,35,30,56) + this->interpErrStr) + HX_(", returning false...",4d,e9,d2,5f)),::hx::SourceInfo(HX_("../crowplexus/iris/Iris.hx",eb,c2,00,2a),154,HX_("crowplexus.iris.Iris",e4,03,e2,62),HX_("get",96,80,4e,00)));
            		}
HXLINE( 156)		if (::hx::IsNotNull( this->interp )) {
HXLINE( 156)			return this->interp->variables->get(field);
            		}
            		else {
HXLINE( 156)			return false;
            		}
HXDLIN( 156)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(Iris_obj,get,return )

void Iris_obj::set(::String name, ::Dynamic value,::hx::Null< bool >  __o_allowOverride){
            		bool allowOverride = __o_allowOverride.Default(true);
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_165_set)
HXLINE( 166)		if (::hx::IsNull( this->interp )) {
HXLINE( 168)			::haxe::Log_obj::trace(((HX_("[Iris:set()]: ",6c,8f,8d,04) + this->interpErrStr) + HX_(", so variables cannot be set.",05,41,56,c9)),::hx::SourceInfo(HX_("../crowplexus/iris/Iris.hx",eb,c2,00,2a),168,HX_("crowplexus.iris.Iris",e4,03,e2,62),HX_("set",a2,9b,57,00)));
HXLINE( 170)			return;
            		}
HXLINE( 173)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 174)			bool _hx_tmp;
HXDLIN( 174)			if (!(allowOverride)) {
HXLINE( 174)				_hx_tmp = !(this->interp->variables->exists(name));
            			}
            			else {
HXLINE( 174)				_hx_tmp = true;
            			}
HXDLIN( 174)			if (_hx_tmp) {
HXLINE( 175)				this->interp->variables->set(name,value);
            			}
            		} catch( ::Dynamic _hx_e) {
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic _g = _hx_e;
HXLINE( 178)				::String v = (HX_("[Iris:set()]: We are sorry, something went terribly wrong, Error: ",4f,96,b7,46) + ::Std_obj::string(::haxe::Exception_obj::caught(_g)));
HXDLIN( 178)				::String _hx_tmp1 = ((HX_("[",5b,00,00,00) + this->ruleSet->name) + HX_(":",3a,00,00,00));
HXDLIN( 178)				::Sys_obj::println( ::Dynamic((((_hx_tmp1 + this->interp->posInfos()->__Field(HX_("lineNumber",dd,81,22,76),::hx::paccDynamic)) + HX_("]: ",43,c4,46,00)) + v)));
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC3(Iris_obj,set,(void))

 ::Dynamic Iris_obj::call(::String fun,::cpp::VirtualArray args){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_188_call)
HXLINE( 189)		if (::hx::IsNull( this->interp )) {
HXLINE( 191)			::haxe::Log_obj::trace(((HX_("[Iris:call()]: ",98,62,5d,11) + this->interpErrStr) + HX_(", so functions cannot be called.",9c,04,fc,d9)),::hx::SourceInfo(HX_("../crowplexus/iris/Iris.hx",eb,c2,00,2a),191,HX_("crowplexus.iris.Iris",e4,03,e2,62),HX_("call",9e,18,ba,41)));
HXLINE( 193)			return 0;
            		}
HXLINE( 196)		if (::hx::IsNull( args )) {
HXLINE( 197)			args = ::cpp::VirtualArray_obj::__new(0);
            		}
HXLINE( 200)		 ::Dynamic ny = this->interp->variables->get(fun);
HXLINE( 201)		bool _hx_tmp;
HXDLIN( 201)		if (::hx::IsNotNull( ny )) {
HXLINE( 201)			_hx_tmp = ::Reflect_obj::isFunction(ny);
            		}
            		else {
HXLINE( 201)			_hx_tmp = false;
            		}
HXDLIN( 201)		if (_hx_tmp) {
HXLINE( 202)			try {
            				HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE( 204)				return  ::Dynamic(::hx::Anon_obj::Create(3)
            					->setFixed(0,HX_("methodReturn",71,ee,16,f3),ny)
            					->setFixed(1,HX_("methodVal",80,62,5d,fa),::Reflect_obj::callMethod(null(),ny,args))
            					->setFixed(2,HX_("methodName",cc,19,0f,12),fun));
            			} catch( ::Dynamic _hx_e) {
            				if (_hx_e.IsClass<  ::Dynamic >() ){
            					HX_STACK_BEGIN_CATCH
            					 ::Dynamic _g = _hx_e;
HXLINE( 207)					::String v = (HX_("[Iris:call()]: We are sorry, something went terribly wrong, Error: ",7b,b7,dc,48) + ::Std_obj::string(::haxe::Exception_obj::caught(_g)));
HXDLIN( 207)					::String _hx_tmp1 = ((HX_("[",5b,00,00,00) + this->ruleSet->name) + HX_(":",3a,00,00,00));
HXDLIN( 207)					::Sys_obj::println( ::Dynamic((((_hx_tmp1 + this->interp->posInfos()->__Field(HX_("lineNumber",dd,81,22,76),::hx::paccDynamic)) + HX_("]: ",43,c4,46,00)) + v)));
            				}
            				else {
            					HX_STACK_DO_THROW(_hx_e);
            				}
            			}
            		}
HXLINE( 211)		return 0;
            	}


HX_DEFINE_DYNAMIC_FUNC2(Iris_obj,call,return )

bool Iris_obj::exists(::String field){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_218_exists)
HXLINE( 220)		if (::hx::IsNull( this->interp )) {
HXLINE( 221)			::haxe::Log_obj::trace(((HX_("[Iris:exists()]: ",9a,c9,e4,ec) + this->interpErrStr) + HX_(", returning false...",4d,e9,d2,5f)),::hx::SourceInfo(HX_("../crowplexus/iris/Iris.hx",eb,c2,00,2a),221,HX_("crowplexus.iris.Iris",e4,03,e2,62),HX_("exists",dc,1d,e0,bf)));
            		}
HXLINE( 223)		if (::hx::IsNotNull( this->interp )) {
HXLINE( 223)			return this->interp->variables->exists(field);
            		}
            		else {
HXLINE( 223)			return false;
            		}
HXDLIN( 223)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC1(Iris_obj,exists,return )

void Iris_obj::destroy(){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_232_destroy)
HXLINE( 233)		if (::crowplexus::iris::Iris_obj::instances->exists(this->ruleSet->name)) {
HXLINE( 234)			::crowplexus::iris::Iris_obj::instances->remove(this->ruleSet->name);
            		}
HXLINE( 236)		this->running = false;
HXLINE( 237)		this->interp = null();
HXLINE( 238)		this->parser = null();
HXLINE( 239)		this->ruleSet = null();
            	}


HX_DEFINE_DYNAMIC_FUNC0(Iris_obj,destroy,(void))

void Iris_obj::irisPrint(::String v){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_260_irisPrint)
HXDLIN( 260)		::String _hx_tmp = ((HX_("[",5b,00,00,00) + this->ruleSet->name) + HX_(":",3a,00,00,00));
HXDLIN( 260)		::Sys_obj::println( ::Dynamic((((_hx_tmp + this->interp->posInfos()->__Field(HX_("lineNumber",dd,81,22,76),::hx::paccDynamic)) + HX_("]: ",43,c4,46,00)) + v)));
            	}


HX_DEFINE_DYNAMIC_FUNC1(Iris_obj,irisPrint,(void))

 ::haxe::ds::StringMap Iris_obj::instances;

void Iris_obj::destroyAll(){
            	HX_STACKFRAME(&_hx_pos_362e1cea85625f87_248_destroyAll)
HXDLIN( 248)		 ::Dynamic key = ::crowplexus::iris::Iris_obj::instances->keys();
HXDLIN( 248)		while(( (bool)(key->__Field(HX_("hasNext",6d,a5,46,18),::hx::paccDynamic)()) )){
HXDLIN( 248)			::String key1 = ( (::String)(key->__Field(HX_("next",f3,84,02,49),::hx::paccDynamic)()) );
HXLINE( 249)			if (::hx::IsNull( ( ( ::crowplexus::iris::Iris)(::crowplexus::iris::Iris_obj::instances->get(key1)) )->interp )) {
HXLINE( 250)				continue;
            			}
HXLINE( 251)			( ( ::crowplexus::iris::Iris)(::crowplexus::iris::Iris_obj::instances->get(key1)) )->destroy();
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Iris_obj,destroyAll,(void))


::hx::ObjectPtr< Iris_obj > Iris_obj::__new(::String scriptCode, ::crowplexus::iris::InitRules rules) {
	::hx::ObjectPtr< Iris_obj > __this = new Iris_obj();
	__this->__construct(scriptCode,rules);
	return __this;
}

::hx::ObjectPtr< Iris_obj > Iris_obj::__alloc(::hx::Ctx *_hx_ctx,::String scriptCode, ::crowplexus::iris::InitRules rules) {
	Iris_obj *__this = (Iris_obj*)(::hx::Ctx::alloc(_hx_ctx, sizeof(Iris_obj), true, "crowplexus.iris.Iris"));
	*(void **)__this = Iris_obj::_hx_vtable;
	__this->__construct(scriptCode,rules);
	return __this;
}

Iris_obj::Iris_obj()
{
}

void Iris_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(Iris);
	HX_MARK_MEMBER_NAME(running,"running");
	HX_MARK_MEMBER_NAME(ruleSet,"ruleSet");
	HX_MARK_MEMBER_NAME(scriptCode,"scriptCode");
	HX_MARK_MEMBER_NAME(interp,"interp");
	HX_MARK_MEMBER_NAME(parser,"parser");
	HX_MARK_MEMBER_NAME(expr,"expr");
	HX_MARK_MEMBER_NAME(interpErrStr,"interpErrStr");
	HX_MARK_END_CLASS();
}

void Iris_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(running,"running");
	HX_VISIT_MEMBER_NAME(ruleSet,"ruleSet");
	HX_VISIT_MEMBER_NAME(scriptCode,"scriptCode");
	HX_VISIT_MEMBER_NAME(interp,"interp");
	HX_VISIT_MEMBER_NAME(parser,"parser");
	HX_VISIT_MEMBER_NAME(expr,"expr");
	HX_VISIT_MEMBER_NAME(interpErrStr,"interpErrStr");
}

::hx::Val Iris_obj::__Field(const ::String &inName,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"get") ) { return ::hx::Val( get_dyn() ); }
		if (HX_FIELD_EQ(inName,"set") ) { return ::hx::Val( set_dyn() ); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"expr") ) { return ::hx::Val( expr ); }
		if (HX_FIELD_EQ(inName,"call") ) { return ::hx::Val( call_dyn() ); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"parse") ) { return ::hx::Val( parse_dyn() ); }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"interp") ) { return ::hx::Val( interp ); }
		if (HX_FIELD_EQ(inName,"parser") ) { return ::hx::Val( parser ); }
		if (HX_FIELD_EQ(inName,"preset") ) { return ::hx::Val( preset_dyn() ); }
		if (HX_FIELD_EQ(inName,"exists") ) { return ::hx::Val( exists_dyn() ); }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"running") ) { return ::hx::Val( running ); }
		if (HX_FIELD_EQ(inName,"ruleSet") ) { return ::hx::Val( ruleSet ); }
		if (HX_FIELD_EQ(inName,"execute") ) { return ::hx::Val( execute_dyn() ); }
		if (HX_FIELD_EQ(inName,"destroy") ) { return ::hx::Val( destroy_dyn() ); }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"irisPrint") ) { return ::hx::Val( irisPrint_dyn() ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"scriptCode") ) { return ::hx::Val( scriptCode ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"interpErrStr") ) { return ::hx::Val( interpErrStr ); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"fixScriptName") ) { return ::hx::Val( fixScriptName_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

bool Iris_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"instances") ) { outValue = ( instances ); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"destroyAll") ) { outValue = destroyAll_dyn(); return true; }
	}
	return false;
}

::hx::Val Iris_obj::__SetField(const ::String &inName,const ::hx::Val &inValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"expr") ) { expr=inValue.Cast<  ::crowplexus::hscript::Expr >(); return inValue; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"interp") ) { interp=inValue.Cast<  ::crowplexus::hscript::Interp >(); return inValue; }
		if (HX_FIELD_EQ(inName,"parser") ) { parser=inValue.Cast<  ::crowplexus::hscript::Parser >(); return inValue; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"running") ) { running=inValue.Cast< bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"ruleSet") ) { ruleSet=inValue.Cast<  ::crowplexus::iris::InitRules >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"scriptCode") ) { scriptCode=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"interpErrStr") ) { interpErrStr=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool Iris_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 9:
		if (HX_FIELD_EQ(inName,"instances") ) { instances=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

void Iris_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_("running",ff,6d,69,eb));
	outFields->push(HX_("ruleSet",06,a0,98,be));
	outFields->push(HX_("scriptCode",d8,8c,a5,3a));
	outFields->push(HX_("interp",d4,79,86,9e));
	outFields->push(HX_("parser",df,9c,88,ed));
	outFields->push(HX_("expr",35,fd,1d,43));
	outFields->push(HX_("interpErrStr",40,4b,d5,e1));
	super::__GetFields(outFields);
};

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo Iris_obj_sMemberStorageInfo[] = {
	{::hx::fsBool,(int)offsetof(Iris_obj,running),HX_("running",ff,6d,69,eb)},
	{::hx::fsObject /*  ::crowplexus::iris::InitRules */ ,(int)offsetof(Iris_obj,ruleSet),HX_("ruleSet",06,a0,98,be)},
	{::hx::fsString,(int)offsetof(Iris_obj,scriptCode),HX_("scriptCode",d8,8c,a5,3a)},
	{::hx::fsObject /*  ::crowplexus::hscript::Interp */ ,(int)offsetof(Iris_obj,interp),HX_("interp",d4,79,86,9e)},
	{::hx::fsObject /*  ::crowplexus::hscript::Parser */ ,(int)offsetof(Iris_obj,parser),HX_("parser",df,9c,88,ed)},
	{::hx::fsObject /*  ::crowplexus::hscript::Expr */ ,(int)offsetof(Iris_obj,expr),HX_("expr",35,fd,1d,43)},
	{::hx::fsString,(int)offsetof(Iris_obj,interpErrStr),HX_("interpErrStr",40,4b,d5,e1)},
	{ ::hx::fsUnknown, 0, null()}
};
static ::hx::StaticInfo Iris_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &Iris_obj::instances,HX_("instances",3e,83,1a,4b)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static ::String Iris_obj_sMemberFields[] = {
	HX_("running",ff,6d,69,eb),
	HX_("ruleSet",06,a0,98,be),
	HX_("scriptCode",d8,8c,a5,3a),
	HX_("interp",d4,79,86,9e),
	HX_("parser",df,9c,88,ed),
	HX_("expr",35,fd,1d,43),
	HX_("interpErrStr",40,4b,d5,e1),
	HX_("fixScriptName",2b,90,09,63),
	HX_("execute",35,0a,0d,cc),
	HX_("parse",33,90,55,bd),
	HX_("preset",5f,b3,c0,ae),
	HX_("get",96,80,4e,00),
	HX_("set",a2,9b,57,00),
	HX_("call",9e,18,ba,41),
	HX_("exists",dc,1d,e0,bf),
	HX_("destroy",fa,2c,86,24),
	HX_("irisPrint",1a,df,8b,62),
	::String(null()) };

static void Iris_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Iris_obj::instances,"instances");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Iris_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Iris_obj::instances,"instances");
};

#endif

::hx::Class Iris_obj::__mClass;

static ::String Iris_obj_sStaticFields[] = {
	HX_("instances",3e,83,1a,4b),
	HX_("destroyAll",47,5c,0e,ae),
	::String(null())
};

void Iris_obj::__register()
{
	Iris_obj _hx_dummy;
	Iris_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("crowplexus.iris.Iris",e4,03,e2,62);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Iris_obj::__GetStatic;
	__mClass->mSetStaticField = &Iris_obj::__SetStatic;
	__mClass->mMarkFunc = Iris_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(Iris_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(Iris_obj_sMemberFields);
	__mClass->mCanCast = ::hx::TCanCast< Iris_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Iris_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Iris_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Iris_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Iris_obj::__boot()
{
{
            	HX_GC_STACKFRAME(&_hx_pos_362e1cea85625f87_26_boot)
HXDLIN(  26)		instances =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
            	}
}

} // end namespace crowplexus
} // end namespace iris
